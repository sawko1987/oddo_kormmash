# Подробная инструкция по парсингу XLS файлов в Odoo

## Содержание
1. [Введение](#введение)
2. [Общая архитектура модуля](#общая-архитектура-модуля)
3. [Структура файлов модуля](#структура-файлов-модуля)
4. [Как работает парсинг - пошаговое описание](#как-работает-парсинг---пошаговое-описание)
5. [Детальное описание компонентов](#детальное-описание-компонентов)
6. [Откуда берутся данные](#откуда-берутся-данные)
7. [Куда вставляются данные](#куда-вставляются-данные)
8. [Примеры работы](#примеры-работы)

---

## Введение

### Что такое парсинг в этом проекте?

**Парсинг** - это процесс чтения и преобразования данных из XLS файла (формат Excel) в структурированный формат, который затем используется для создания записей в базе данных Odoo.

В данном проекте парсинг используется для импорта производственных данных:
- **Номенклатура** (изделия/машины) - создаются как продукты с BOM (Bill of Materials - спецификация материалов)
- **Материалы** - создаются как компоненты в BOM
- **Операции** - создаются как операции производства
- **Рабочие центры** - создаются по названиям цехов

### Где находится модуль парсинга?

Модуль находится в директории: `addons/mrp_xls_import/`

---

## Общая архитектура модуля

### Основные компоненты:

```
mrp_xls_import/
├── __init__.py                    # Инициализация модуля
├── __manifest__.py                # Описание модуля (зависимости, файлы)
├── models/                        # Модели данных
│   ├── __init__.py
│   ├── mrp_bom_import.py          # ⭐ ОСНОВНОЙ КЛАСС ПАРСИНГА
│   └── mrp_production.py
├── wizard/                        # Мастер импорта (UI)
│   ├── __init__.py
│   └── mrp_xls_import_wizard.py   # ⭐ ИНТЕРФЕЙС ПОЛЬЗОВАТЕЛЯ
├── views/                         # XML представления (формы)
│   └── mrp_xls_import_views.xml
└── security/                      # Права доступа
    └── ir.model.access.csv
```

### Поток данных:

```
1. Пользователь → Выбирает XLS файл в интерфейсе
2. Wizard (mrp_xls_import_wizard.py) → Получает файл
3. MrpBomImport.parse_xls_file() → Читает и парсит файл
4. MrpBomImport.process_import_data() → Обрабатывает данные
5. Odoo ORM → Создает записи в базе данных
```

---

## Структура файлов модуля

### 1. `__manifest__.py` - Описание модуля

**Что это?** Файл, который описывает модуль для Odoo: его название, версию, зависимости, какие файлы нужно загрузить.

**Ключевые моменты:**
- `depends: ['mrp', 'product', 'stock']` - модуль требует установленные модули Manufacturing, Products и Stock
- `data: [...]` - список файлов, которые нужно загрузить при установке модуля

**Откуда берется?** Создается разработчиком при создании модуля.

**Куда вставляется?** Odoo читает этот файл при установке модуля через Apps.

---

### 2. `models/mrp_bom_import.py` - Основной класс парсинга

**Что это?** Главный класс, который содержит всю логику парсинга и обработки данных.

**Основные методы:**

#### `parse_xls_file(file_data)` - Парсинг файла
- **Откуда берется `file_data`?** Из поля `file` в wizard (это base64-закодированные данные файла)
- **Что делает?**
  1. Декодирует base64 в бинарные данные
  2. Открывает файл с помощью библиотеки `xlrd`
  3. Читает первый лист Excel
  4. Пропускает заголовки (первые 3 строки)
  5. Читает каждую строку и преобразует в словарь
  6. Возвращает список словарей с данными

#### `process_import_data(rows_data, update_existing)` - Обработка данных
- **Откуда берется `rows_data`?** Из метода `parse_xls_file()`
- **Что делает?**
  1. Проходит по всем строкам дважды (двухпроходная обработка)
  2. Создает/обновляет продукты, BOM, материалы, операции
  3. Возвращает статистику

#### Вспомогательные методы:
- `get_or_create_product()` - получает или создает продукт
- `get_or_create_uom()` - получает или создает единицу измерения
- `get_or_create_workcenter()` - получает или создает рабочий центр
- `_parse_quantity()` - парсит количество из значения
- `_parse_owner_row()` - парсит номер строки владельца

---

### 3. `wizard/mrp_xls_import_wizard.py` - Интерфейс пользователя

**Что это?** Класс, который представляет форму для загрузки файла.

**Основные поля:**
- `file` - бинарное поле для загрузки файла
- `file_name` - имя файла
- `update_existing` - флаг обновления существующих записей
- `import_result` - HTML с результатами импорта

**Основной метод:**

#### `action_import()` - Запуск импорта
- **Откуда вызывается?** При нажатии кнопки "Import" в форме
- **Что делает?**
  1. Получает файл из поля `file`
  2. Вызывает `parse_xls_file()` для парсинга
  3. Вызывает `process_import_data()` для обработки
  4. Формирует HTML отчет
  5. Показывает результаты пользователю

---

### 4. `views/mrp_xls_import_views.xml` - XML представления

**Что это?** XML файл, который описывает интерфейс (форму) для импорта.

**Что содержит?**
- Форму с полем для загрузки файла
- Кнопки "Import" и "Close"
- Меню в разделе Manufacturing

**Откуда берется?** Создается разработчиком.

**Куда вставляется?** Odoo читает этот файл при установке модуля и создает интерфейс.

---

### 5. `security/ir.model.access.csv` - Права доступа

**Что это?** CSV файл с правами доступа к моделям.

**Что содержит?**
- Какие группы пользователей могут читать/писать/создавать/удалять записи

**Откуда берется?** Создается разработчиком.

**Куда вставляется?** Odoo читает этот файл при установке модуля и устанавливает права.

---

## Как работает парсинг - пошаговое описание

### Шаг 1: Пользователь загружает файл

**Где происходит?** В браузере, в интерфейсе Odoo.

**Что происходит?**
1. Пользователь открывает меню: **Manufacturing → Products → Import from XLS**
2. Открывается форма (wizard) с полем для загрузки файла
3. Пользователь выбирает файл (например, `Плановое.xls`)
4. Файл загружается в браузер и кодируется в base64
5. Пользователь нажимает кнопку "Import"

**Куда попадает файл?** В поле `file` модели `mrp.xls.import.wizard` (это бинарное поле, хранит base64-кодированные данные).

---

### Шаг 2: Вызов метода action_import()

**Где происходит?** В методе `action_import()` класса `MrpXlsImportWizard`.

**Код:**
```python
def action_import(self):
    file_data = self.file  # Получаем base64-кодированные данные
    import_helper = self.env['mrp.bom.import']  # Получаем класс парсера
    rows_data = import_helper.parse_xls_file(file_data)  # Парсим файл
```

**Что происходит?**
1. Получаем данные файла из поля `file`
2. Создаем экземпляр класса `mrp.bom.import` (это модель `MrpBomImport`)
3. Вызываем метод `parse_xls_file()` с данными файла

---

### Шаг 3: Парсинг файла (parse_xls_file)

**Где происходит?** В методе `parse_xls_file()` класса `MrpBomImport`.

**Откуда берется `file_data`?** Из предыдущего шага - это base64-строка.

#### 3.1. Декодирование файла

```python
file_contents = base64.b64decode(file_data)
```

**Что происходит?**
- Base64-строка преобразуется в бинарные данные (байты)
- Это нужно, потому что Odoo хранит файлы в base64, а библиотека `xlrd` работает с бинарными данными

**Пример:**
```
Вход: "UEsDBBQAAAAI..." (base64)
Выход: b'\x50\x4b\x03\x04...' (бинарные данные)
```

#### 3.2. Открытие файла с помощью xlrd

```python
wb = xlrd.open_workbook(
    file_contents=file_contents,
    ignore_workbook_corruption=True,
    logfile=xlrd_log
)
```

**Что происходит?**
- Библиотека `xlrd` открывает Excel файл из бинарных данных
- `ignore_workbook_corruption=True` - игнорирует некоторые ошибки повреждения файла
- `logfile` - перенаправляет предупреждения в StringIO (чтобы не выводить в консоль)

**Откуда берется библиотека xlrd?** Устанавливается вместе с Odoo или отдельно через pip.

**Что получаем?** Объект `Workbook` - это представление Excel файла в памяти.

#### 3.3. Получение первого листа

```python
sheet = wb.sheet_by_index(0)
```

**Что происходит?**
- Получаем первый лист (sheet) из книги Excel
- Индекс 0 означает первый лист

**Что получаем?** Объект `Sheet` - это представление листа Excel.

**Свойства листа:**
- `sheet.nrows` - количество строк
- `sheet.ncols` - количество столбцов
- `sheet.name` - имя листа

#### 3.4. Пропуск заголовков

```python
start_row = 3  # Пропускаем первые 3 строки (0, 1, 2)
```

**Почему пропускаем?** Первые строки обычно содержат заголовки таблицы, а не данные.

**Пример структуры файла:**
```
Строка 0: [Заголовок таблицы]
Строка 1: [Пустая строка]
Строка 2: [Названия колонок: №п/п, Наименование, ...]
Строка 3: [ПЕРВАЯ СТРОКА ДАННЫХ] ← начинаем отсюда
Строка 4: [Вторая строка данных]
...
```

#### 3.5. Маппинг колонок (COLUMN_MAPPING)

**Что это?** Словарь, который связывает названия полей с номерами колонок в Excel.

**Код:**
```python
COLUMN_MAPPING = {
    'row_number': 0,           # Колонка 0 (A) - №п/п
    'product_name': 1,         # Колонка 1 (B) - Наименование полного изделия
    'hierarchy_level': 2,      # Колонка 2 (C) - Уровень в иерархии
    'object_type': 3,          # Колонка 3 (D) - Вид объекта
    'object_name': 4,          # Колонка 4 (E) - Наименование объекта
    'code_1c': 5,              # Колонка 5 (F) - Код объекта из 1С
    'skip_7': 6,               # Колонка 6 (G) - Пропускаем
    'qty_per_detail': 7,       # Колонка 7 (H) - Количество на деталь
    'norm_per_product': 8,      # Колонка 8 (I) - Норма на изделие
    'uom': 9,                  # Колонка 9 (J) - Ед. измерения
    'price': 10,               # Колонка 10 (K) - Цена
    'cost': 11,                # Колонка 11 (L) - Стоимость
    'currency': 12,            # Колонка 12 (M) - Валюта
    'owner_name': 13,          # Колонка 13 (N) - Владелец объекта
    'skip_15': 14,             # Колонка 14 (O) - Пропускаем
    'owner_row_number': 15,    # Колонка 15 (P) - Номер строки владельца
    'workshop': 16,            # Колонка 16 (Q) - Цех
    'skip_18': 17,             # Колонка 17 (R) - Пропускаем
}
```

**Как используется?**
- Когда читаем строку, для каждого поля из маппинга берем значение из соответствующей колонки
- Например, для поля `object_name` берем значение из колонки 4 (E)

**Откуда берется этот маппинг?** Разработчик создает его на основе структуры исходного Excel файла.

#### 3.6. Чтение строк данных

```python
for row_idx in range(start_row, sheet.nrows):
    row_data = {}
    for key, col_idx in self.COLUMN_MAPPING.items():
        if col_idx < sheet.ncols:
            cell_value = sheet.cell_value(row_idx, col_idx)
            # Обработка значения...
            row_data[key] = cell_value
    rows_data.append(row_data)
```

**Что происходит?**
1. Проходим по всем строкам начиная с `start_row` (строка 3)
2. Для каждой строки создаем словарь `row_data`
3. Для каждого поля из `COLUMN_MAPPING`:
   - Берем значение ячейки: `sheet.cell_value(row_idx, col_idx)`
   - Обрабатываем значение (преобразуем типы, обрабатываем пустые значения)
   - Сохраняем в словарь
4. Добавляем словарь в список `rows_data`

**Пример результата:**
```python
rows_data = [
    {
        'row_number': 1.0,
        'product_name': 'Машина А',
        'hierarchy_level': 1,
        'object_type': 'номенклатура',
        'object_name': 'Машина А',
        'code_1c': 'M001',
        'qty_per_detail': None,
        'norm_per_product': None,
        'uom': 'шт',
        ...
    },
    {
        'row_number': 2.0,
        'product_name': 'Машина А',
        'hierarchy_level': 2,
        'object_type': 'материал',
        'object_name': 'Болт М8',
        'code_1c': 'B001',
        'qty_per_detail': None,
        'norm_per_product': 10.0,
        'uom': 'шт',
        'owner_row_number': 1,
        ...
    },
    ...
]
```

#### 3.7. Обработка типов данных

**Проблема:** Excel может хранить числа как float, даже если это целые числа (например, 1.0 вместо 1).

**Решение:**
```python
if isinstance(cell_value, float):
    # Проверка на NaN (Not a Number)
    if cell_value != cell_value:  # NaN check
        cell_value = None
    # Для целых чисел преобразуем в int
    elif key in ('owner_row_number', 'hierarchy_level') and cell_value == int(cell_value):
        cell_value = int(cell_value)
```

**Что происходит?**
- Если значение - float и это целое число (например, 1.0), преобразуем в int (1)
- Если значение NaN (пустая ячейка с формулой), преобразуем в None
- Для числовых полей (количество, норма) оставляем как float

#### 3.8. Пропуск пустых строк

```python
if not row_num and not object_name and not object_type and not code_1c:
    skipped_count += 1
    continue  # Пропускаем эту строку
```

**Что происходит?**
- Если строка полностью пустая (нет основных полей), пропускаем её
- Это нужно, чтобы не обрабатывать пустые строки в конце файла

#### 3.9. Возврат результата

```python
return rows_data  # Список словарей с данными
```

**Что получаем?** Список словарей, где каждый словарь - это одна строка из Excel файла.

**Куда попадает результат?** Возвращается в метод `action_import()`, где сохраняется в переменную `rows_data`.

---

### Шаг 4: Обработка данных (process_import_data)

**Где происходит?** В методе `process_import_data()` класса `MrpBomImport`.

**Откуда берется `rows_data`?** Из предыдущего шага - это список словарей с данными из Excel.

**Что происходит?** Двухпроходная обработка данных.

#### 4.1. ПРОХОД 1: Определение продуктов

**Цель:** Найти все продукты уровня 1 (номенклатура с уровнем иерархии = 1).

```python
for idx, row_data in enumerate(rows_data):
    object_type = str(row_data.get('object_type', '')).strip()
    product_name = str(row_data.get('product_name', '')).strip()
    hierarchy_level = row_data.get('hierarchy_level', '')
    
    if ('номенклатура' in object_type.lower()):
        level = int(hierarchy_level) if hierarchy_level else 0
        if level == 1 and product_name:
            # Это продукт уровня 1
            current_product_row = row_num
            products_by_row[row_num] = row_data
```

**Что происходит?**
1. Проходим по всем строкам
2. Ищем строки, где:
   - `object_type` содержит "номенклатура"
   - `hierarchy_level` = 1
   - `product_name` заполнен
3. Сохраняем эти строки в словарь `products_by_row`

**Зачем это нужно?** Чтобы знать, какие строки являются главными продуктами (изделиями), а какие - компонентами.

**Результат:** Словарь `products_by_row`, где ключ - номер строки, значение - данные строки.

#### 4.2. ПРОХОД 2: Обработка всех объектов

**Цель:** Создать/обновить все записи в базе данных.

**Что происходит в цикле:**

##### 4.2.1. Определение текущего продукта

```python
if row_num in products_by_row:
    current_product_row = row_num  # Это новый продукт
```

**Что происходит?** Если текущая строка - это продукт уровня 1, запоминаем её номер как текущий продукт.

##### 4.2.2. Обработка номенклатуры

```python
if 'номенклатура' in object_type.lower():
    # Создаем или получаем продукт
    product = self.get_or_create_product(code_1c, object_name, product_type, product_cache)
    
    # Создаем или получаем BOM
    bom = self.env['mrp.bom'].search([...])
    if not bom:
        bom = self.env['mrp.bom'].create({...})
```

**Что происходит?**
1. Создаем или получаем продукт по коду 1С
2. Создаем или получаем BOM (спецификацию материалов) для этого продукта
3. Сохраняем в словари для последующего использования

**Куда вставляется?** 
- Продукт → таблица `product_product` и `product_template`
- BOM → таблица `mrp_bom`

##### 4.2.3. Обработка материалов

```python
elif 'материал' in object_type.lower():
    owner_row = self._parse_owner_row(row_data.get('owner_row_number'))
    if owner_row and owner_row in bom_by_row:
        bom = bom_by_row[owner_row]  # Получаем BOM владельца
        
        # Создаем продукт-материал
        material_product = self.get_or_create_product(...)
        
        # Получаем количество из колонки 9 (norm_per_product)
        qty = self._parse_quantity(row_data.get('norm_per_product'))
        
        # Создаем строку BOM
        bom_line = self.env['mrp.bom.line'].create({
            'bom_id': bom.id,
            'product_id': material_product.id,
            'product_qty': qty,
            'product_uom_id': uom.id,
        })
```

**Что происходит?**
1. Определяем владельца (родительскую номенклатуру) по `owner_row_number`
2. Получаем BOM владельца из словаря `bom_by_row`
3. Создаем или получаем продукт-материал
4. Парсим количество из колонки 9 (`norm_per_product`)
5. Создаем строку BOM (компонент в спецификации)

**Откуда берется количество?** Из колонки 9 (I) Excel файла - поле `norm_per_product`.

**Куда вставляется?** 
- Материал как продукт → таблица `product_product`
- Строка BOM → таблица `mrp_bom_line`

##### 4.2.4. Обработка операций

```python
elif 'операция' in object_type.lower():
    owner_row = self._parse_owner_row(row_data.get('owner_row_number'))
    if owner_row and owner_row in bom_by_row:
        bom = bom_by_row[owner_row]
        
        # Получаем или создаем рабочий центр
        workshop = row_data.get('workshop', '')
        workcenter = self.get_or_create_workcenter(workshop, workcenter_cache)
        
        # Получаем длительность из колонки 9 (norm_per_product)
        duration = self._parse_quantity(row_data.get('norm_per_product'))
        
        # Создаем операцию
        operation = self.env['mrp.routing.workcenter'].create({
            'bom_id': bom.id,
            'workcenter_id': workcenter.id,
            'name': object_name,
            'time_cycle_manual': duration,
        })
```

**Что происходит?**
1. Определяем владельца (номенклатуру, для которой операция)
2. Получаем BOM владельца
3. Создаем или получаем рабочий центр по названию цеха
4. Парсим длительность операции из колонки 9 (`norm_per_product`)
5. Создаем операцию в маршруте производства

**Откуда берется цех?** Из колонки 17 (Q) Excel файла - поле `workshop`.

**Откуда берется длительность?** Из колонки 9 (I) Excel файла - поле `norm_per_product` (для операций это длительность, а не количество).

**Куда вставляется?**
- Рабочий центр → таблица `mrp_workcenter`
- Операция → таблица `mrp_routing_workcenter`

#### 4.3. Кеширование

**Зачем нужно?** Чтобы не делать повторные запросы к базе данных для одних и тех же объектов.

**Примеры кешей:**
```python
product_cache = {}      # {code_1c: product} - кеш продуктов
bom_cache = {}          # {product_tmpl_id: bom} - кеш BOM
bom_line_cache = {}     # {(bom_id, product_id): bom_line} - кеш строк BOM
workcenter_cache = {}   # {workshop_name: workcenter} - кеш рабочих центров
operation_cache = {}    # {(bom_id, workcenter_id, name): operation} - кеш операций
```

**Как работает?**
1. Перед поиском в базе данных проверяем кеш
2. Если объект есть в кеше - используем его
3. Если нет - ищем в базе, создаем если нужно, и сохраняем в кеш

**Пример:**
```python
# Вместо:
product = self.env['product.product'].search([('default_code', '=', code_1c)])

# Используем кеш:
if code_1c in product_cache:
    product = product_cache[code_1c]  # Быстро!
else:
    product = self.env['product.product'].search([...])
    product_cache[code_1c] = product  # Сохраняем в кеш
```

#### 4.4. Оптимизация памяти

**Проблема:** При обработке больших файлов может закончиться память.

**Решение:**
```python
# Периодически очищаем кеш
if len(product_cache) > 500:
    product_cache.clear()

# Периодически делаем flush (сохраняем изменения в БД)
if idx % flush_interval == 0:
    self.env.cr.flush()  # Сохраняем изменения
    self.env.registry.clear_cache()  # Очищаем кеш ORM
```

**Что происходит?**
- Каждые 50 записей делаем `flush()` - сохраняем изменения в базу данных
- Когда кеш становится слишком большим, очищаем его
- Это предотвращает переполнение памяти

#### 4.5. Валидация владельца

**Зачем нужно?** Чтобы убедиться, что компонент действительно принадлежит указанному владельцу.

```python
def _validate_owner_relationship(self, row_data, parent_row_data):
    owner_name = str(row_data.get('owner_name', '')).strip()
    parent_object_name = str(parent_row_data.get('object_name', '')).strip()
    parent_product_name = str(parent_row_data.get('product_name', '')).strip()
    
    parent_name = parent_object_name if parent_object_name else parent_product_name
    
    return owner_name.lower().strip() == parent_name.lower().strip()
```

**Что происходит?**
1. Берем `owner_name` из текущей строки (колонка 14)
2. Берем название родительской номенклатуры
3. Сравниваем (без учета регистра)
4. Если не совпадает - пропускаем строку с ошибкой

**Зачем это нужно?** Чтобы избежать ошибок, когда в файле неправильно указан владелец.

#### 4.6. Возврат статистики

```python
stats = {
    'products_created': 0,
    'products_updated': 0,
    'boms_created': 0,
    'boms_updated': 0,
    'bom_lines_created': 0,
    'operations_created': 0,
    'workcenters_created': 0,
    'errors': [],
}
return stats
```

**Что происходит?** В процессе обработки считаем, сколько чего создано/обновлено, и возвращаем статистику.

**Куда попадает статистика?** В метод `action_import()`, где используется для формирования отчета.

---

### Шаг 5: Формирование отчета

**Где происходит?** В методе `_format_import_result()` класса `MrpXlsImportWizard`.

**Откуда берется `stats`?** Из предыдущего шага - это словарь со статистикой.

**Что происходит?**
1. Формируется HTML-код с таблицами и статистикой
2. HTML сохраняется в поле `import_result`
3. Поле `show_result` устанавливается в `True`
4. Форма обновляется и показывает результаты

**Куда вставляется?** В поле `import_result` модели `mrp.xls.import.wizard`, которое отображается в форме.

---

## Детальное описание компонентов

### 1. Метод get_or_create_product()

**Назначение:** Получить существующий продукт или создать новый.

**Параметры:**
- `code_1c` - код продукта из 1С (используется как `default_code`)
- `name` - название продукта
- `object_type` - тип продукта ('consu', 'product', 'service')
- `product_cache` - кеш продуктов (опционально)

**Что происходит:**
1. Проверяем кеш - если продукт уже есть, возвращаем его
2. Ищем продукт в базе по `default_code` (код 1С)
3. Если не найден - создаем новый:
   ```python
   product_template = self.env['product.template'].create({
       'name': name,
       'type': object_type,
       'default_code': code_1c,
   })
   product = product_template.product_variant_ids[0]
   ```
4. Если найден - обновляем название, если изменилось
5. Сохраняем в кеш
6. Возвращаем продукт

**Куда вставляется продукт?**
- `product_template` → таблица `product_template`
- `product_variant` → таблица `product_product`

**Откуда берется код 1С?** Из колонки 6 (F) Excel файла - поле `code_1c`.

---

### 2. Метод get_or_create_uom()

**Назначение:** Получить существующую единицу измерения или создать новую.

**Параметры:**
- `uom_name` - название единицы измерения (например, "шт", "кг", "м")

**Что происходит:**
1. Если название пустое - возвращаем стандартную единицу (шт)
2. Ищем единицу измерения по названию
3. Если не найдена - создаем новую:
   ```python
   uom = self.env['uom.uom'].create({
       'name': uom_name,
       'relative_factor': 1.0,
   })
   ```
4. Возвращаем единицу измерения

**Куда вставляется?** Таблица `uom_uom`.

**Откуда берется название?** Из колонки 10 (J) Excel файла - поле `uom`.

---

### 3. Метод get_or_create_workcenter()

**Назначение:** Получить существующий рабочий центр или создать новый.

**Параметры:**
- `workshop_name` - название цеха/рабочего центра
- `workcenter_cache` - кеш рабочих центров (опционально)

**Что происходит:**
1. Если название пустое - возвращаем `False`
2. Проверяем кеш
3. Ищем рабочий центр по названию
4. Если не найден - создаем новый:
   ```python
   workcenter = self.env['mrp.workcenter'].create({
       'name': workshop_name,
   })
   ```
5. Сохраняем в кеш
6. Возвращаем рабочий центр

**Куда вставляется?** Таблица `mrp_workcenter`.

**Откуда берется название?** Из колонки 17 (Q) Excel файла - поле `workshop`.

---

### 4. Метод _parse_quantity()

**Назначение:** Преобразовать значение в число (количество).

**Параметры:**
- `value` - значение для парсинга (может быть float, int, str, None)

**Что происходит:**
1. Если `None` - возвращаем `None`
2. Если число (int/float) - возвращаем как float
3. Если строка:
   - Убираем пробелы
   - Если пустая - возвращаем `None`
   - Пытаемся преобразовать в float
4. Если ошибка - возвращаем `None`

**Примеры:**
```python
_parse_quantity(10.0)    # → 10.0
_parse_quantity("10.5")   # → 10.5
_parse_quantity("")       # → None
_parse_quantity(None)     # → None
```

**Где используется?** Для парсинга количества материалов и норм на изделие.

---

### 5. Метод _parse_owner_row()

**Назначение:** Преобразовать значение в целое число (номер строки владельца).

**Параметры:**
- `value` - значение для парсинга

**Что происходит:**
1. Если `None` - возвращаем `None`
2. Если число - преобразуем в int
3. Если строка - пытаемся преобразовать в int (через float для обработки "8.0")
4. Если ошибка - возвращаем `None`

**Примеры:**
```python
_parse_owner_row(8.0)     # → 8
_parse_owner_row("8")     # → 8
_parse_owner_row("8.0")   # → 8
_parse_owner_row("")      # → None
```

**Где используется?** Для определения родительской номенклатуры (владельца компонента).

**Откуда берется значение?** Из колонки 16 (P) Excel файла - поле `owner_row_number`.

---

## Откуда берутся данные

### 1. Исходный Excel файл

**Где находится?** Пользователь загружает его через интерфейс Odoo.

**Формат:** .xls или .xlsx (формат Microsoft Excel).

**Структура:**
- Первые 3 строки - заголовки (пропускаются)
- Строка 3 и далее - данные
- 18 колонок (A-R)

**Пример структуры файла:**

| A (0) | B (1) | C (2) | D (3) | E (4) | F (5) | ... | H (7) | I (8) | J (9) | ... | N (13) | P (15) | Q (16) |
|-------|-------|-------|-------|-------|-------|-----|-------|-------|-------|-----|--------|--------|--------|
| №п/п | Наименование изделия | Уровень | Вид объекта | Наименование объекта | Код 1С | ... | Кол-во на деталь | Норма на изделие | Ед. изм. | ... | Владелец | Номер строки владельца | Цех |
| 1 | Машина А | 1 | номенклатура | Машина А | M001 | ... | | | шт | ... | | | |
| 2 | Машина А | 2 | материал | Болт М8 | B001 | ... | | 10.0 | шт | ... | Машина А | 1 | |
| 3 | Машина А | 2 | операция | Сборка | O001 | ... | | 60.0 | мин | ... | Машина А | 1 | Цех 1 |

### 2. Маппинг колонок (COLUMN_MAPPING)

**Где находится?** В файле `addons/mrp_xls_import/models/mrp_bom_import.py`, строка 22.

**Откуда берется?** Разработчик создает его на основе структуры исходного Excel файла.

**Как используется?** При чтении каждой строки Excel файла значения из колонок преобразуются в поля словаря согласно маппингу.

### 3. Библиотека xlrd

**Что это?** Python библиотека для чтения Excel файлов.

**Откуда берется?** Устанавливается вместе с Odoo или отдельно через pip.

**Как используется?**
```python
import xlrd
wb = xlrd.open_workbook(file_contents=file_contents)
sheet = wb.sheet_by_index(0)
cell_value = sheet.cell_value(row_idx, col_idx)
```

### 4. База данных Odoo

**Что это?** PostgreSQL база данных, где хранятся все данные Odoo.

**Откуда берутся существующие записи?** Из таблиц базы данных через Odoo ORM:
```python
product = self.env['product.product'].search([('default_code', '=', code_1c)])
```

**Куда вставляются новые записи?** В таблицы базы данных через Odoo ORM:
```python
product = self.env['product.product'].create({...})
```

---

## Куда вставляются данные

### 1. Продукты (Products)

**Таблицы базы данных:**
- `product_template` - шаблон продукта (название, тип, код)
- `product_product` - вариант продукта (наследуется от шаблона)

**Как создается:**
```python
product_template = self.env['product.template'].create({
    'name': 'Машина А',
    'type': 'product',
    'default_code': 'M001',
})
product = product_template.product_variant_ids[0]
```

**Откуда берутся данные:**
- `name` - из колонки 5 (E) - `object_name` или `product_name`
- `type` - определяется по `object_type` ('product' для номенклатуры)
- `default_code` - из колонки 6 (F) - `code_1c`

**Где используется?** Для всех объектов: номенклатура, материалы.

---

### 2. BOM (Bill of Materials - Спецификация материалов)

**Таблицы базы данных:**
- `mrp_bom` - спецификация материалов

**Как создается:**
```python
bom = self.env['mrp.bom'].create({
    'product_tmpl_id': product.product_tmpl_id.id,
    'product_qty': 1.0,
    'type': 'normal',
})
```

**Откуда берутся данные:**
- `product_tmpl_id` - связь с продуктом (номенклатурой)
- `product_qty` - всегда 1.0 (количество производимого продукта)
- `type` - всегда 'normal'

**Где используется?** Для номенклатуры (изделий), которые имеют компоненты.

---

### 3. Строки BOM (BOM Lines - Компоненты)

**Таблицы базы данных:**
- `mrp_bom_line` - строки спецификации (компоненты)

**Как создается:**
```python
bom_line = self.env['mrp.bom.line'].create({
    'bom_id': bom.id,
    'product_id': material_product.id,
    'product_qty': 10.0,
    'product_uom_id': uom.id,
})
```

**Откуда берутся данные:**
- `bom_id` - связь с BOM (из словаря `bom_by_row`)
- `product_id` - продукт-компонент (материал или номенклатура)
- `product_qty` - из колонки 8 (H) для номенклатур (`qty_per_detail`) или колонки 9 (I) для материалов (`norm_per_product`)
- `product_uom_id` - единица измерения (из колонки 10 (J))

**Где используется?** Для материалов и номенклатур уровня 2+ (подсборок).

---

### 4. Рабочие центры (Workcenters)

**Таблицы базы данных:**
- `mrp_workcenter` - рабочие центры (цеха)

**Как создается:**
```python
workcenter = self.env['mrp.workcenter'].create({
    'name': 'Цех 1',
})
```

**Откуда берутся данные:**
- `name` - из колонки 17 (Q) - `workshop`

**Где используется?** Для операций производства.

---

### 5. Операции (Operations)

**Таблицы базы данных:**
- `mrp_routing_workcenter` - операции в маршруте производства

**Как создается:**
```python
operation = self.env['mrp.routing.workcenter'].create({
    'bom_id': bom.id,
    'workcenter_id': workcenter.id,
    'name': 'Сборка',
    'time_cycle_manual': 60.0,
    'sequence': 1,
})
```

**Откуда берутся данные:**
- `bom_id` - связь с BOM (из словаря `bom_by_row`)
- `workcenter_id` - рабочий центр (из колонки 17 (Q))
- `name` - из колонки 5 (E) - `object_name`
- `time_cycle_manual` - из колонки 9 (I) - `norm_per_product` (для операций это длительность)
- `sequence` - порядковый номер операции

**Где используется?** Для операций производства.

---

### 6. Маршруты производства (Routes)

**Таблицы базы данных:**
- `stock_route` - маршруты
- `product_template_route_rel` - связь продуктов с маршрутами

**Как создается:**
```python
manufacture_route = self.env['stock.route'].search([
    ('rule_ids.action', '=', 'manufacture'),
])
product.product_tmpl_id.route_ids = [(4, manufacture_route.id)]
```

**Откуда берутся данные:**
- Маршрут "Manufacture" ищется в базе (обычно создается модулем `mrp`)
- Добавляется к продуктам с BOM

**Где используется?** Для номенклатуры с BOM, чтобы можно было создавать производственные заказы.

---

## Примеры работы

### Пример 1: Импорт простого изделия

**Исходный файл (Excel):**

| Строка | A | B | C | D | E | F | H | I | J | P | Q |
|--------|---|---|---|---|---|---|---|---|---|---|---|
| 3 | 1 | Машина А | 1 | номенклатура | Машина А | M001 | | | шт | | |
| 4 | 2 | Машина А | 2 | материал | Болт М8 | B001 | | 10.0 | шт | 1 | |
| 5 | 3 | Машина А | 2 | операция | Сборка | O001 | | 60.0 | мин | 1 | Цех 1 |

**Что происходит:**

1. **Строка 3 (номенклатура):**
   - Создается продукт "Машина А" (M001)
   - Создается BOM для этого продукта

2. **Строка 4 (материал):**
   - Создается продукт "Болт М8" (B001)
   - Создается строка BOM в BOM "Машина А" с количеством 10.0 шт

3. **Строка 5 (операция):**
   - Создается рабочий центр "Цех 1"
   - Создается операция "Сборка" в BOM "Машина А" с длительностью 60.0 мин

**Результат в базе данных:**

**product_template:**
- id=1, name='Машина А', default_code='M001', type='product'
- id=2, name='Болт М8', default_code='B001', type='consu'

**mrp_bom:**
- id=1, product_tmpl_id=1, product_qty=1.0

**mrp_bom_line:**
- id=1, bom_id=1, product_id=2, product_qty=10.0, product_uom_id=1

**mrp_workcenter:**
- id=1, name='Цех 1'

**mrp_routing_workcenter:**
- id=1, bom_id=1, workcenter_id=1, name='Сборка', time_cycle_manual=60.0

---

### Пример 2: Иерархическая структура (подсборка)

**Исходный файл (Excel):**

| Строка | A | B | C | D | E | F | H | I | J | P | Q |
|--------|---|---|---|---|---|---|---|---|---|---|---|
| 3 | 1 | Машина А | 1 | номенклатура | Машина А | M001 | | | шт | | |
| 4 | 2 | Машина А | 2 | номенклатура | Узел 1 | U001 | 2.0 | | шт | 1 | |
| 5 | 3 | Машина А | 3 | материал | Болт М8 | B001 | | 4.0 | шт | 2 | |
| 6 | 4 | Машина А | 2 | операция | Сборка узла | O001 | | 30.0 | мин | 2 | Цех 1 |
| 7 | 5 | Машина А | 2 | операция | Финальная сборка | O002 | | 60.0 | мин | 1 | Цех 2 |

**Что происходит:**

1. **Строка 3:** Создается продукт "Машина А" (M001) и его BOM

2. **Строка 4:** Создается продукт "Узел 1" (U001) и его BOM, добавляется в BOM "Машина А" как компонент (количество 2.0)

3. **Строка 5:** Создается продукт "Болт М8" (B001), добавляется в BOM "Узел 1" как компонент (количество 4.0)

4. **Строка 6:** Создается операция "Сборка узла" в BOM "Узел 1"

5. **Строка 7:** Создается операция "Финальная сборка" в BOM "Машина А"

**Результат в базе данных:**

**Иерархия BOM:**
```
Машина А (BOM id=1)
  ├─ Узел 1 (BOM id=2) × 2.0 шт
  │   ├─ Болт М8 × 4.0 шт
  │   └─ Операция: Сборка узла (30 мин, Цех 1)
  └─ Операция: Финальная сборка (60 мин, Цех 2)
```

---

## Заключение

### Резюме процесса парсинга:

1. **Пользователь загружает файл** → данные попадают в поле `file` (base64)
2. **Wizard вызывает parse_xls_file()** → файл декодируется и читается с помощью xlrd
3. **Данные преобразуются в словари** → каждая строка Excel становится словарем
4. **process_import_data() обрабатывает данные** → создаются/обновляются записи в базе данных
5. **Формируется отчет** → пользователь видит результаты импорта

### Ключевые моменты:

- **Маппинг колонок** определяет, какая колонка Excel соответствует какому полю
- **Двухпроходная обработка** сначала находит продукты, потом обрабатывает все объекты
- **Кеширование** ускоряет работу и уменьшает нагрузку на базу данных
- **Валидация** проверяет корректность данных перед созданием записей
- **Обработка ошибок** позволяет продолжить работу даже при ошибках в отдельных строках

### Где искать проблемы:

1. **Файл не читается** → проверьте формат (.xls/.xlsx) и целостность файла
2. **Данные не создаются** → проверьте логи Odoo, возможно ошибки валидации
3. **Неправильные связи** → проверьте `owner_row_number` и `owner_name` в файле
4. **Медленная работа** → для больших файлов это нормально, используйте кеширование

---

## Дополнительная информация

### Логирование

Все этапы парсинга логируются с помощью модуля `logging`. Логи можно найти в логах Odoo сервера.

**Уровни логирования:**
- `INFO` - общая информация о процессе
- `DEBUG` - детальная информация для отладки
- `WARNING` - предупреждения (пропущенные строки, ошибки валидации)
- `ERROR` - критические ошибки

### Производительность

- **Кеширование** - уменьшает количество запросов к БД
- **Пакетная обработка** - периодические flush() для освобождения памяти
- **Очистка кеша** - предотвращает переполнение памяти

### Расширение функциональности

Для добавления новых типов объектов или полей:
1. Обновите `COLUMN_MAPPING` если нужно
2. Добавьте обработку нового типа в `process_import_data()`
3. Создайте методы для создания новых объектов (если нужно)

---

**Дата создания:** 2024
**Версия модуля:** 1.0
**Автор инструкции:** AI Assistant
